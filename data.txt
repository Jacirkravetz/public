var scopedElements = doc.Descendants()
    .Where(e => e.Name.LocalName.Equals(scopeTag, StringComparison.OrdinalIgnoreCase))
    .ToList();


var sectionElement = scope.Elements()
    .FirstOrDefault(e => e.Name.LocalName.Equals(section, StringComparison.OrdinalIgnoreCase));

using System.Data;
using System.Xml.Linq;

public static class XmlSectionFilterExtractor
{
    public static DataTable ExtractScopedSections(
        string xmlContent,
        string scopeTag,
        List<string> includedSections,
        bool includeRootAttributes = false)
    {
        var dataTable = new DataTable();
        var doc = XDocument.Parse(xmlContent);

        // Remove namespaces
        foreach (var e in doc.Descendants())
            e.Name = e.Name.LocalName;

        var rows = new List<Dictionary<string, string>>();

        var scopeElements = doc.Descendants(scopeTag);

        foreach (var scopeElement in scopeElements)
        {
            var row = new Dictionary<string, string>();

            // Add attributes from the scope element (e.g., <Order TmInForce="0" Typ="2">)
            foreach (var attr in scopeElement.Attributes())
            {
                row[$"{scopeTag}_@{attr.Name.LocalName}"] = attr.Value;
            }

            foreach (var sectionName in includedSections)
            {
                var sectionElement = scopeElement.Element(sectionName);
                if (sectionElement != null)
                {
                    ProcessElement(sectionElement, sectionName, row);
                }
            }

            rows.Add(row);
        }

        // Define columns based on all keys found
        var allKeys = rows.SelectMany(r => r.Keys).Distinct();
        foreach (var key in allKeys)
        {
            dataTable.Columns.Add(key);
        }

        // Fill rows
        foreach (var r in rows)
        {
            var dataRow = dataTable.NewRow();
            foreach (var key in r.Keys)
            {
                dataRow[key] = r[key];
            }
            dataTable.Rows.Add(dataRow);
        }

        return dataTable;
    }

    private static void ProcessElement(XElement element, string path, Dictionary<string, string> row)
    {
        // Process attributes
        foreach (var attr in element.Attributes())
        {
            row[$"{path}_@{attr.Name.LocalName}"] = attr.Value;
        }

        // Process child elements
        foreach (var child in element.Elements())
        {
            var newPath = $"{path}_{child.Name.LocalName}";
            if (child.HasElements)
                ProcessElement(child, newPath, row);
            else
                row[newPath] = child.Value;
        }

        // If element has text and no children, add value
        if (!element.HasElements && !string.IsNullOrWhiteSpace(element.Value))
        {
            row[path] = element.Value;
        }
    }
}
