using Confluent.SchemaRegistry.Serdes;
using Confluent.Kafka;
using Avro.Generic;
using Google.Protobuf;
using System;

public static class SerializerFactory
{
    public static void ConfigurarSerializers<TKey, TValue>(
        ProducerBuilder<TKey, TValue> builder,
        ISchemaRegistryClient? schemaRegistryClient,
        SerializationFormat keyFormat,
        SerializationFormat valueFormat)
    {
        // Key
        builder.SetKeySerializer(ObterSerializer<TKey>(keyFormat, schemaRegistryClient));

        // Value
        builder.SetValueSerializer(ObterSerializer<TValue>(valueFormat, schemaRegistryClient));
    }

    private static ISerializer<T> ObterSerializer<T>(
        SerializationFormat format,
        ISchemaRegistryClient? schemaRegistryClient)
    {
        return format switch
        {
            SerializationFormat.Avro => typeof(T) == typeof(GenericRecord)
                ? (ISerializer<T>)new AvroSerializer<GenericRecord>(schemaRegistryClient!)
                : throw new NotSupportedException("Avro requer GenericRecord."),
            
            SerializationFormat.Json => new JsonSerializer<T>(schemaRegistryClient!),

            SerializationFormat.Protobuf => typeof(T).IsSubclassOf(typeof(IMessage))
                ? (ISerializer<T>)new ProtobufSerializer<IMessage>(schemaRegistryClient!)
                : throw new NotSupportedException("Protobuf requer tipos que herdam de IMessage."),

            SerializationFormat.Utf8 => (ISerializer<T>)Serializers.Utf8,

            SerializationFormat.Xml => throw new NotSupportedException("XML não é suportado nativamente pelo Kafka."),

            SerializationFormat.Yaml => throw new NotSupportedException("YAML não é suportado nativamente pelo Kafka."),

            _ => throw new NotSupportedException($"Formato de serialização não suportado: {format}")
        };
    }
}
