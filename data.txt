var scopedElements = doc.Descendants()
    .Where(e => e.Name.LocalName.Equals(scopeTag, StringComparison.OrdinalIgnoreCase))
    .ToList();


var sectionElement = scope.Elements()
    .FirstOrDefault(e => e.Name.LocalName.Equals(section, StringComparison.OrdinalIgnoreCase));
using System.Data;
using System.Xml.Linq;

public static class XmlRecursiveExtractor
{
    public static DataTable ExtractSections(
        string xmlContent,
        string scopeTag,
        List<string> includedSections)
    {
        var dataTable = new DataTable();
        var doc = XDocument.Parse(xmlContent);

        // Remove namespaces
        foreach (var e in doc.Descendants())
            e.Name = e.Name.LocalName;

        var rows = new List<Dictionary<string, string>>();
        var scopeElements = doc.Descendants(scopeTag);

        foreach (var scopeElement in scopeElements)
        {
            var row = new Dictionary<string, string>();

            // Atributos da tag raiz (ex: Order_@Tipo)
            foreach (var attr in scopeElement.Attributes())
                row[$"{scopeTag}_@{attr.Name.LocalName}"] = attr.Value;

            if (includedSections.Contains("*"))
            {
                foreach (var child in scopeElement.Elements())
                {
                    ProcessElementRecursive(child, $"{scopeTag}_{child.Name.LocalName}", row);
                }
            }
            else
            {
                foreach (var section in includedSections)
                {
                    var sectionElements = scopeElement.Elements(section);
                    int count = sectionElements.Count();
                    int index = 0;

                    foreach (var elem in sectionElements)
                    {
                        string basePath = count > 1
                            ? $"{scopeTag}_{section}[{index}]"
                            : $"{scopeTag}_{section}";

                        ProcessElementRecursive(elem, basePath, row);
                        index++;
                    }
                }
            }

            rows.Add(row);
        }

        // Definir colunas
        foreach (var key in rows.SelectMany(r => r.Keys).Distinct())
            dataTable.Columns.Add(key);

        // Adicionar linhas
        foreach (var row in rows)
        {
            var dataRow = dataTable.NewRow();
            foreach (var key in row.Keys)
                dataRow[key] = row[key];
            dataTable.Rows.Add(dataRow);
        }

        return dataTable;
    }

    private static void ProcessElementRecursive(
        XElement element,
        string currentPath,
        Dictionary<string, string> row)
    {
        // Atributos
        foreach (var attr in element.Attributes())
            row[$"{currentPath}_@{attr.Name.LocalName}"] = attr.Value;

        var grouped = element.Elements()
            .GroupBy(e => e.Name.LocalName)
            .ToDictionary(g => g.Key, g => g.ToList());

        foreach (var pair in grouped)
        {
            var children = pair.Value;
            for (int i = 0; i < children.Count; i++)
            {
                var child = children[i];
                string path = children.Count > 1
                    ? $"{currentPath}_{child.Name.LocalName}[{i}]"
                    : $"{currentPath}_{child.Name.LocalName}";

                if (child.HasElements || child.HasAttributes)
                    ProcessElementRecursive(child, path, row);
                else
                    row[path] = child.Value;
            }
        }

        if (!element.HasElements && !string.IsNullOrWhiteSpace(element.Value))
        {
            row[currentPath] = element.Value;
        }
    }
}
