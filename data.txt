public interface IFixSessionManager
{
    Task ConfigureSessionAsync(CancellationToken cancellationToken);
    Task StartAsync(CancellationToken cancellationToken);
    Task StopAsync(CancellationToken cancellationToken);
    Task SendMessageAsync(Message message, CancellationToken cancellationToken);

    event Func<Message, SessionID, Task>? MessageReceived;
}



using QuickFix;
using QuickFix.Transport;

public class FixSessionManager : IFixSessionManager
{
    private readonly ILogger<FixSessionManager> _logger;
    private SocketInitiator? _initiator;
    private SessionID? _sessionID;
    private SessionSettings? _settings;
    private IFixMessageHandler? _handler;

    private DateTime _lastLogonTime;

    public event Func<Message, SessionID, Task>? MessageReceived;

    public FixSessionManager(ILogger<FixSessionManager> logger)
    {
        _logger = logger;
    }

    public async Task ConfigureSessionAsync(CancellationToken cancellationToken)
    {
        _settings = new SessionSettings("Config/fixconfig.cfg");

        _handler = new FixMessageHandler(_logger);
        _handler.OnLogonEvent += OnLogon;
        _handler.OnLogoutEvent += OnLogout;
        _handler.OnAppMessageReceived += async (message, sessionId) =>
        {
            _logger.LogInformation("Dispatching received application message.");
            if (MessageReceived != null)
                await MessageReceived.Invoke(message, sessionId);
        };

        var storeFactory = new FileStoreFactory(_settings);
        var logFactory = new FileLogFactory(_settings);
        var messageFactory = new DefaultMessageFactory();

        _initiator = new SocketInitiator(_handler, storeFactory, _settings, logFactory, messageFactory);

        // Assume single session
        var sessionIds = _settings.GetSessions();
        if (sessionIds.Count > 0)
        {
            _sessionID = sessionIds[0];
        }
        else
        {
            _logger.LogError("No session found in config.");
            throw new InvalidOperationException("SessionID not found.");
        }

        _logger.LogInformation("Session configured.");
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _initiator?.Start();
        _logger.LogInformation("FIX session started.");
        await Task.CompletedTask;
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        _initiator?.Stop();
        _logger.LogInformation("FIX session stopped.");
        await Task.CompletedTask;
    }

    public async Task SendMessageAsync(Message message, CancellationToken cancellationToken)
    {
        if (_sessionID == null)
        {
            _logger.LogError("Cannot send message: session not configured.");
            return;
        }

        while (!cancellationToken.IsCancellationRequested)
        {
            var session = Session.LookupSession(_sessionID);
            if (session != null && session.IsLoggedOn && IsSessionReadyToSend(session))
            {
                _logger.LogInformation("Sending message: {0}", message.ToString());
                session.Send(message);
                return;
            }

            _logger.LogWarning("Session not ready. Retrying...");
            await Task.Delay(500, cancellationToken);
        }

        _logger.LogWarning("Message send was cancelled.");
    }

    private void OnLogon(SessionID sessionID)
    {
        _lastLogonTime = DateTime.UtcNow;
        _logger.LogInformation("Logon successful: {0}", sessionID);
    }

    private void OnLogout(SessionID sessionID)
    {
        _logger.LogInformation("Logout received: {0}", sessionID);
    }

    private bool IsSessionReadyToSend(Session session)
    {
        // Simples: espera 2 segundos após logon para garantir sincronização de SeqNum
        return session.IsLoggedOn && (DateTime.UtcNow - _lastLogonTime > TimeSpan.FromSeconds(2));
    }
}
