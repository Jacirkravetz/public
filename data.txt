using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Xml.Linq;

public static class XmlSectionFilterExtractor
{
    public static DataTable ExtractScopedSections(
        string xmlContent,
        string scopeTag,
        List<string> includedSections,
        bool includeRootAttributes = true)
    {
        var doc = XDocument.Parse(xmlContent);
        var root = doc.Root ?? throw new Exception("Invalid XML.");
        var dataTable = new DataTable();
        var scopedElements = doc.Descendants(scopeTag).ToList();

        foreach (var scope in scopedElements)
        {
            var rowDict = new Dictionary<string, string>();

            foreach (var section in includedSections)
            {
                var sectionElement = scope.Element(section);
                if (sectionElement != null)
                {
                    var flattened = FlattenElement(sectionElement, $"{scopeTag}_{section}");
                    foreach (var kvp in flattened)
                        rowDict[kvp.Key] = kvp.Value;
                }
            }

            // Optional: include data from scope attributes (like id)
            foreach (var attr in scope.Attributes())
                rowDict[$"{scopeTag}_{attr.Name.LocalName}"] = attr.Value;

            // Optional: include data from root (e.g., global tags)
            if (includeRootAttributes)
            {
                foreach (var element in root.Elements())
                {
                    if (element.Name.LocalName != scopeTag && !element.HasElements)
                    {
                        rowDict[$"Root_{element.Name.LocalName}"] = element.Value;
                    }
                }
            }

            // Create columns dynamically
            foreach (var col in rowDict.Keys)
            {
                if (!dataTable.Columns.Contains(col))
                    dataTable.Columns.Add(col);
            }

            var row = dataTable.NewRow();
            foreach (var kvp in rowDict)
                row[kvp.Key] = kvp.Value;

            dataTable.Rows.Add(row);
        }

        return dataTable;
    }

    private static Dictionary<string, string> FlattenElement(XElement element, string prefix)
    {
        var result = new Dictionary<string, string>();

        foreach (var attr in element.Attributes())
            result[$"{prefix}_{attr.Name.LocalName}"] = attr.Value;

        foreach (var child in element.Elements())
        {
            var childPrefix = $"{prefix}_{child.Name.LocalName}";
            if (child.HasElements)
            {
                var nested = FlattenElement(child, childPrefix);
                foreach (var kvp in nested)
                    result[kvp.Key] = kvp.Value;
            }
            else
            {
                result[childPrefix] = child.Value;
            }
        }

        if (!element.HasElements && !element.HasAttributes)
            result[prefix] = element.Value;

        return result;
    }
}


string xml = @"
<NotaFiscal>
  <DataGlobal>2025-05-08</DataGlobal>
  <Pedido id='123'>
    <Comprador>
      <Nome>João</Nome>
      <CPF>12345678900</CPF>
    </Comprador>
    <EnderecoEntrega>
      <Rua>Rua A</Rua>
      <Cidade>São Paulo</Cidade>
    </EnderecoEntrega>
    <Pagamento>
      <Metodo>Cartao</Metodo>
      <Valor>500</Valor>
    </Pagamento>
  </Pedido>
  <Pedido id='456'>
    <Comprador>
      <Nome>Maria</Nome>
      <CPF>98765432100</CPF>
    </Comprador>
    <EnderecoEntrega>
      <Rua>Rua B</Rua>
      <Cidade>Rio de Janeiro</Cidade>
    </EnderecoEntrega>
    <Pagamento>
      <Metodo>Pix</Metodo>
      <Valor>300</Valor>
    </Pagamento>
  </Pedido>
</NotaFiscal>";

var result = XmlSectionFilterExtractor.ExtractScopedSections(
    xml,
    scopeTag: "Pedido",
    includedSections: new List<string> { "Comprador", "EnderecoEntrega" },
    includeRootAttributes: true
);

foreach (DataRow row in result.Rows)
{
    foreach (DataColumn col in result.Columns)
        Console.Write($"{col.ColumnName}: {row[col]} | ");
    Console.WriteLine();
}

