using System;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

public class ProcessCutOffWindowService : StepBase
{
    private readonly ILogger<ProcessCutOffWindowService> _logger;
    private readonly SemaphoreSlim _semaphore = new(1, 1);

    public ProcessCutOffWindowService(ILogger<ProcessCutOffWindowService> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteStepAsync(TabularMessage input, CutOffWindow[] windows, CancellationToken cancellationToken)
    {
        var tradeDateTime = ExtractTradeDateTime(input);
        var tradeLimitTime = ExtractTradeLimitTime(input);

        _logger.LogInformation("üîç Validating CutOff for Step...");

        var isValid = IsWithinCutoff(windows, tradeDateTime, tradeLimitTime, out var matchedWindow);

        if (isValid)
        {
            _logger.LogInformation("‚úÖ Trade is within CutOff window. Executing next step.");
            await base.Push(input, cancellationToken);
        }
        else
        {
            _logger.LogWarning("‚õî Trade is outside CutOff window. Waiting for valid window...");
            LogAvailableWindows(windows, tradeDateTime, tradeLimitTime);

            await WaitUntilWithinCutoffAsync(windows, tradeDateTime, tradeLimitTime, cancellationToken);

            _logger.LogInformation("‚úÖ Window is now valid. Executing Push.");
            await base.Push(input, cancellationToken);
        }
    }

    private async Task WaitUntilWithinCutoffAsync(CutOffWindow[] windows, DateTime? localTradeTime, TimeSpan? localTradeLimitTime, CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            await _semaphore.WaitAsync(cancellationToken);
            try
            {
                if (IsWithinCutoff(windows, localTradeTime, localTradeLimitTime, out _))
                {
                    return;
                }
            }
            finally
            {
                _semaphore.Release();
            }

            await Task.Delay(TimeSpan.FromSeconds(10), cancellationToken); // Aguarda antes de verificar novamente
        }
    }

    private bool IsWithinCutoff(CutOffWindow[] windows, DateTime? localTradeTime, TimeSpan? localTradeLimitTime, out CutOffWindow? matched)
    {
        matched = null;
        var nowUtc = DateTime.UtcNow;

        foreach (var window in windows)
        {
            if (!TryLoadTimeZone(window.TimeZoneId, out var tz))
            {
                _logger.LogWarning("‚ö†Ô∏è Invalid TimeZoneId: {TimeZoneId}", window.TimeZoneId);
                continue;
            }

            var localNow = TimeZoneInfo.ConvertTimeFromUtc(nowUtc, tz);
            if (window.DayOfWeek != localNow.DayOfWeek)
                continue;

            var time = localNow.TimeOfDay;
            if (time < window.StartTime || time > window.EndTime)
                continue;

            if (localTradeLimitTime.HasValue && localTradeTime.HasValue)
            {
                if (localTradeTime.Value.TimeOfDay > localTradeLimitTime.Value)
                    continue;
            }

            matched = window;
            return true;
        }

        return false;
    }

    private bool TryLoadTimeZone(string timeZoneId, out TimeZoneInfo timeZone)
    {
        timeZone = null!;
        try
        {
            timeZone = TimeZoneInfo.FindSystemTimeZoneById(timeZoneId);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private void LogAvailableWindows(CutOffWindow[] windows, DateTime? tradeTime, TimeSpan? tradeLimit)
    {
        var sb = new StringBuilder();
        sb.AppendLine("üïí Available CutOff Windows:");

        foreach (var window in windows.OrderBy(w => w.DayOfWeek).ThenBy(w => w.StartTime))
        {
            sb.AppendLine(FormatWindow(window, tradeTime, tradeLimit));
        }

        _logger.LogInformation(sb.ToString());
    }

    private string FormatWindow(CutOffWindow w, DateTime? tradeTime, TimeSpan? tradeLimit)
    {
        return $" - StepId: {w.StepId}\n" +
               $"   TimeZone: {w.TimeZoneId}\n" +
               $"   DayOfWeek: {w.DayOfWeek} ({(int)w.DayOfWeek})\n" +
               $"   StartTime: {w.StartTime:hh\\:mm}\n" +
               $"   EndTime: {w.EndTime:hh\\:mm}\n" +
               $"   LocalTradeTimeField: {(tradeTime.HasValue ? tradeTime.Value.ToString("HH:mm:ss") : "null")}\n" +
               $"   LocalTradeLimitTime: {(tradeLimit.HasValue ? tradeLimit.Value.ToString("hh\\:mm") : "null")}";
    }

    private DateTime? ExtractTradeDateTime(TabularMessage input)
    {
        if (input.TryGetValue("TradeDate", out var value) && DateTime.TryParse(value?.ToString(), out var date))
            return date;

        return null;
    }

    private TimeSpan? ExtractTradeLimitTime(TabularMessage input)
    {
        if (input.TryGetValue("TradeLimit", out var value) && TimeSpan.TryParse(value?.ToString(), out var time))
            return time;

        return null;
    }
}
