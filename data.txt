using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

class Program
{
    static void Main()
    {
        string filePath = "caminho_do_arquivo.csv";
        char expectedDelimiter = ';'; // Altere para o delimitador esperado

        char detectedDelimiter = DetectDelimiter(filePath);

        Console.WriteLine($"Delimitador detectado: '{(detectedDelimiter == '\t' ? "TAB" : detectedDelimiter.ToString())}'");

        // Validação para verificar se o delimitador detectado é o esperado
        if (detectedDelimiter != expectedDelimiter)
        {
            Console.WriteLine($"⚠️ ATENÇÃO: O delimitador esperado era '{expectedDelimiter}', mas foi detectado '{detectedDelimiter}'.");
            Console.WriteLine("Verifique se o arquivo está correto ou ajuste a configuração.");
        }

        // Agora você pode processar o arquivo corretamente com o delimitador detectado
    }

    static char DetectDelimiter(string filePath)
    {
        // Lista de delimitadores comuns
        char[] commonDelimiters = { ',', ';', '\t', '|', ':', ' ', '/', '\\', '-', '*', '@', '!', '#', '$', '=', '~' };
        Dictionary<char, int> delimiterCounts = new Dictionary<char, int>();

        // Inicializa o contador para cada delimitador
        foreach (char delimiter in commonDelimiters)
        {
            delimiterCounts[delimiter] = 0;
        }

        using (StreamReader reader = new StreamReader(filePath))
        {
            int linesToCheck = 10; // Número de linhas analisadas (pode ser ajustado)
            for (int i = 0; i < linesToCheck; i++)
            {
                string? line = reader.ReadLine();
                if (string.IsNullOrWhiteSpace(line)) continue;

                foreach (char delimiter in commonDelimiters)
                {
                    int count = line.Count(c => c == delimiter);
                    delimiterCounts[delimiter] += count;
                }
            }
        }

        // Retorna o delimitador que apareceu mais vezes
        return delimiterCounts.OrderByDescending(d => d.Value).First().Key;
    }
}
