public async Task WaitUntilSessionIsReadyAsync(
    int pollIntervalMs = 500,
    CancellationToken cancellationToken = default)
{
    while (!_app.IsLoggedOn)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            _logger.Warn("Waiting for FIX session was cancelled externally.");
            return;
        }

        _logger.Info("Waiting for FIX session to be logged on...");
        await Task.Delay(pollIntervalMs, cancellationToken);
    }

    _logger.Info("FIX session is now logged on.");
}



public async Task<bool> SendAsync(Message message, CancellationToken cancellationToken = default)
{
    await WaitUntilSessionIsReadyAsync(cancellationToken: cancellationToken);

    try
    {
        bool success = Session.SendToTarget(message, _app.CurrentSessionID);
        if (!success)
        {
            _logger.Error("Message was not sent: SendToTarget returned false.");
            return false;
        }

        _logger.Info("FIX message sent successfully.");
        return true;
    }
    catch (SessionNotFound ex)
    {
        _logger.Error($"Session not found: {ex.Message}");
    }
    catch (DoNotSend ex)
    {
        _logger.Warn($"DoNotSend was thrown: {ex.Message}");
    }
    catch (Exception ex)
    {
        _logger.Error($"Unexpected error during message sending: {ex.Message}");
    }

    return false;
}


var cts = new CancellationTokenSource(); // pode ser cancelado externamente

// Aguardar logon indefinidamente (a menos que cancelado externamente)
await fixManager.WaitUntilSessionIsReadyAsync(cancellationToken: cts.Token);

var message = new QuickFix.FIX44.Heartbeat();
await fixManager.SendAsync(message, cancellationToken: cts.Token);
