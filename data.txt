Passo 1: Crie a interface IExecutionStepService
Crie essa interface no projeto FixIntegration.Application (ou onde fizer sentido):

csharp
Copiar
Editar
// IExecutionStepService.cs
using System.Threading;
using System.Threading.Tasks;

public interface IExecutionStepService
{
    Task Init(CancellationToken cancellationToken);
    Task<object?> Execute(object? input, CancellationToken cancellationToken);
}
✅ Passo 2: Faça o FixSessionService implementar a interface
csharp
Copiar
Editar
// FixSessionService.cs
using Microsoft.Extensions.Logging;
using QuickFix;
using System.Data;
using System.Threading;
using System.Threading.Tasks;

public class FixSessionService : IExecutionStepService
{
    private readonly ILogger<FixSessionService> _logger;
    private readonly IFixAppWrapper _fixAppWrapper;

    public FixSessionService(ILogger<FixSessionService> logger, IFixAppWrapper fixAppWrapper)
    {
        _logger = logger;
        _fixAppWrapper = fixAppWrapper;
    }

    public Task Init(CancellationToken cancellationToken)
    {
        _fixAppWrapper.ConfigureSession("fixsettings.cfg");
        return Task.CompletedTask;
    }

    public Task<object?> Execute(object? input, CancellationToken cancellationToken)
    {
        if (input is DataTable table)
        {
            _logger.LogInformation($"DataTable received with {table.Rows.Count} row(s). Columns: {string.Join(", ", table.Columns.Cast<DataColumn>().Select(c => c.ColumnName))}");
            return Task.FromResult<object?>(null);
        }
        else
        {
            return _fixAppWrapper.RunAsync();
        }
    }

    public void Stop()
    {
        _fixAppWrapper.Stop();
        _fixAppWrapper.MoveFiles();
    }
}
✅ Passo 3: Ajuste a injeção de dependência no Program.cs
Atualize o Program.cs para registrar corretamente o serviço e a interface:

csharp
Copiar
Editar
services.AddSingleton<IFixAppWrapper, FixAppWrapper>();

services.AddSingleton<IExecutionStepService>(provider =>
{
    var logger = provider.GetRequiredService<ILogger<FixSessionService>>();
    var fixApp = provider.GetRequiredService<IFixAppWrapper>();
    return new FixSessionService(logger, fixApp);
});
Se for necessário também injetar o FixSessionService diretamente (como no Worker), adicione:

csharp
Copiar
Editar
services.AddSingleton<FixSessionService>(provider => 
    (FixSessionService)provider.GetRequiredService<IExecutionStepService>());
✅ Passo 4: Atualize o Worker se necessário
Se estiver usando FixSessionService diretamente no Worker.cs, mantenha como está. Mas se preferir trabalhar com a abstração:

csharp
Copiar
Editar
private readonly IExecutionStepService _executionStepService;

public Worker(ILogger<Worker> logger, IExecutionStepService executionStepService)
{
    _logger = logger;
    _executionStepService = executionStepService;
}
